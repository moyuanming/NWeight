#include "LocalIncludeFile.h"
#define KeyNumber ((3+6+4+1) +5*(5*5) +(2*5*(2+8+2+2))+3 + 5*4*2)
int main(void);
int KeyValue[KeyNumber]={
	VK_SHANGBAN,VK_0,VK_3,VK_0,VK_8,VK_0,VK_1,VK_RETURN,VK_1,VK_2,VK_3,VK_4,VK_RETURN,VK_OPEN_YPD,
	VK_1,VK_RETURN  ,VK_RETURN,VK_MONI, VK_1,
	VK_2,VK_RETURN  ,VK_RETURN,VK_MONI, VK_1,
	VK_3,VK_RETURN  ,VK_RETURN,VK_MONI, VK_1,
	VK_4,VK_RETURN  ,VK_RETURN,VK_MONI, VK_1,
	VK_5,VK_RETURN  ,VK_RETURN,VK_MONI, VK_1,

	VK_1,VK_JUNCHE  ,VK_RETURN,VK_MONI, VK_1,
	VK_2,VK_JUNCHE  ,VK_RETURN,VK_MONI, VK_1,
	VK_3,VK_JUNCHE  ,VK_RETURN,VK_MONI, VK_1,
	VK_4,VK_JUNCHE  ,VK_RETURN,VK_MONI, VK_1,
	VK_5,VK_JUNCHE  ,VK_RETURN,VK_MONI, VK_1,

	VK_1,VK_GONGWU  ,VK_RETURN,VK_MONI, VK_1,
	VK_2,VK_GONGWU  ,VK_RETURN,VK_MONI, VK_1,
	VK_3,VK_GONGWU  ,VK_RETURN,VK_MONI, VK_1,
	VK_4,VK_GONGWU  ,VK_RETURN,VK_MONI, VK_1,
	VK_5,VK_GONGWU  ,VK_RETURN,VK_MONI, VK_1,

	VK_1,VK_LONGYONG    ,VK_0,VK_0,VK_1,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_2,VK_LONGYONG    ,VK_0,VK_0,VK_2,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_3,VK_LONGYONG    ,VK_0,VK_0,VK_3,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_4,VK_LONGYONG    ,VK_0,VK_0,VK_4,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_5,VK_LONGYONG    ,VK_0,VK_0,VK_5,VK_RETURN,VK_RETURN,VK_MONI, VK_1,

	VK_1,VK_LVSETONGDAO ,VK_0,VK_0,VK_1,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_2,VK_LVSETONGDAO ,VK_0,VK_0,VK_2,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_3,VK_LVSETONGDAO ,VK_0,VK_0,VK_4,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_4,VK_LVSETONGDAO ,VK_0,VK_0,VK_5,VK_RETURN,VK_RETURN,VK_MONI, VK_1,
	VK_5,VK_LVSETONGDAO ,VK_0,VK_0,VK_6,VK_RETURN,VK_RETURN,VK_MONI, VK_1,


	VK_1,VK_YOUHUICARD ,VK_0,VK_0,VK_0,VK_0,VK_7,VK_2,VK_4,VK_2,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_2,VK_YOUHUICARD  ,VK_0,VK_0,VK_0,VK_0,VK_7,VK_2,VK_4,VK_2,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_3,VK_YOUHUICARD  ,VK_0,VK_0,VK_0,VK_0,VK_7,VK_2,VK_4,VK_2,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_4,VK_YOUHUICARD  ,VK_0,VK_0,VK_0,VK_0,VK_7,VK_2,VK_4,VK_2,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_5,VK_YOUHUICARD  ,VK_0,VK_0,VK_0,VK_0,VK_7,VK_2,VK_4,VK_2,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,


	VK_1,VK_MOUNTHCARD  ,VK_0,VK_0,VK_0,VK_1,VK_1,VK_3,VK_9,VK_9,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_2,VK_MOUNTHCARD  ,VK_0,VK_0,VK_0,VK_1,VK_1,VK_3,VK_9,VK_9,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_3,VK_MOUNTHCARD  ,VK_0,VK_0,VK_0,VK_1,VK_1,VK_3,VK_9,VK_9,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_4,VK_MOUNTHCARD  ,VK_0,VK_0,VK_0,VK_1,VK_1,VK_3,VK_9,VK_9,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,
	VK_5,VK_MOUNTHCARD  ,VK_0,VK_0,VK_0,VK_1,VK_1,VK_3,VK_9,VK_9,VK_RETURN,VK_RETURN,VK_MONI,   VK_1,


	VK_CLOSE_YPD,VK_XIABAN, VK_RETURN

} ;



int COMFD ;
int set_Parity(int fd,int databits,int stopbits,int parity)
{ 
	struct termios options; 
	if  ( tcgetattr( fd,&options)  !=  0) { 
		perror("SetupSerial 1");     
		return(FALSE);  
	}
	options.c_cflag &= ~CSIZE; 
	switch (databits) /*设置数据位数*/
	{   
	case 7:		
		options.c_cflag |= CS7; 
		break;
	case 8:     
		options.c_cflag |= CS8;
		break;   
	default:    
		fprintf(stderr,"Unsupported data size\n"); return (FALSE);  
	}
	switch (parity) 
	{   
	case 'n':
	case 'N':    
		options.c_cflag &= ~PARENB;   /* Clear parity enable */
		options.c_iflag &= ~INPCK;     /* Enable parity checking */ 
		break;  
	case 'o':   
	case 'O':     
		options.c_cflag |= (PARODD | PARENB); /* 设置为奇效验*/  
		options.c_iflag |= INPCK;             /* Disnable parity checking */ 
		break;  
	case 'e':  
	case 'E':   
		options.c_cflag |= PARENB;     /* Enable parity */    
		options.c_cflag &= ~PARODD;   /* 转换为偶效验*/     
		options.c_iflag |= INPCK;       /* Disnable parity checking */
		break;
	case 'S': 
	case 's':  /*as no parity*/   
		options.c_cflag &= ~PARENB;
		options.c_cflag &= ~CSTOPB;break;  
	default:   
		fprintf(stderr,"Unsupported parity\n");    
		return (FALSE);  
	}  
	/* 设置停止位*/  
	switch (stopbits)
	{   
	case 1:    
		options.c_cflag &= ~CSTOPB;  
		break;  
	case 2:    
		options.c_cflag |= CSTOPB;  
		break;
	default:    
		fprintf(stderr,"Unsupported stop bits\n");  
		return (FALSE); 
	} 
	/* Set input parity option */ 
	if (parity != 'n')   
		options.c_iflag |= INPCK; 
	tcflush(fd,TCIFLUSH);
	options.c_cc[VTIME] = 150; /* 设置超时15 seconds*/   
	options.c_cc[VMIN] = 0; /* Update the options and do it NOW */
	if (tcsetattr(fd,TCSANOW,&options) != 0)   
	{ 
		perror("SetupSerial 3");   
		return (FALSE);  
	} 
	return (TRUE);  
}
setlines(int fd, int rts, int dtr)
{
	int lines = 0;

	if (rts) lines |= TIOCM_RTS;
	if (dtr) lines |= TIOCM_DTR;

	ioctl(fd,TIOCMSET,&lines);
}
int serial_init(int nCOM, int nBaud)
{	
    struct termios newtio;
    char szCOM[20];
    sprintf(szCOM,"/dev/COM%d",nCOM);	
	echoic("COM %s Speed %d",szCOM,nBaud);
    COMFD= open(szCOM,O_RDWR | O_NOCTTY /*| O_NONBLOCK*/);
    if(COMFD< 0)
    {	
        return -1;
    }
//return 	set_Parity(COMFD,8,1,'N');
	//setlines(COMFD,0,0);
    bzero(&newtio, sizeof(newtio));/* 清除结构体以放入新的序列埠设定值 */
/*
BAUDRATE: 设定 bps 的速度. 你也可以用 cfsetispeed 及 cfsetospeed 来设定.
CRTSCTS : 输出资料的硬体流量控制 (只能在具完整线路的缆线下工作  参考 Serial-HOWTO 第七节)
CS8     : 8n1 (8 位元, 不做同位元检查,1 个终止位元)
CLOCAL  : 本地连线, 不具数据机控制功能
CREAD   : 致能接收字元
*/
    newtio.c_cflag = nBaud |  CS8 | CLOCAL | CREAD   ;

/*
IGNPAR  : 忽略经同位元检查後, 错误的位元组
ICRNL   : 比 CR 对应成 NL (否则当输入讯号有 CR 时不会终止输入)
            在不然把装置设定成 raw 模式(没有其它的输入处理)
 */

    newtio.c_iflag = IGNPAR ;//| ICRNL;/*HH IGNPAR*/
/*
 Raw 模式输出.
*/
    newtio.c_oflag = 0;

/*
 ICANON  : 致能标准输入, 使所有回应机能停用, 并不送出信号以叫用程式
*/
    newtio.c_lflag = 0;//ICANON; /*HH 0*/


	/*newtio.c_cflag |= CLOCAL | CREAD;
	newtio.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
	newtio.c_oflag &= ~OPOST;
	newtio.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);*/

/*
 初始化所有的控制特性
 预设值可以在 /usr/include/termios.h 找到, 在注解中也有,
 但我们在这不需要看它们
*/
    newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */
    newtio.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
    newtio.c_cc[VERASE]   = 0;     /* del */
    newtio.c_cc[VKILL]    = 0;     /* @ */
    newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */
    newtio.c_cc[VTIME]    = 0;     /* 不使用分割字元组的计时器 */
    newtio.c_cc[VMIN]     = 1;     /* 在读取到 1 个字元前先停止 */
    newtio.c_cc[VSWTC]    = 0;     /* '\0' */
    newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */
    newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */
    newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
    newtio.c_cc[VEOL]     = 0;     /* '\0' */
    newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */
    newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */
    newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */
    newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
    newtio.c_cc[VEOL2]    = 0;     /* '\0' */


/*
  现在清除数据机线并启动序列埠的设定
*/
    tcflush(COMFD, TCIFLUSH);	
    tcsetattr(COMFD,TCSANOW,&newtio);	

    return 0;
}




int serial_write(int nCOM,unsigned char *byWriteBuf,int nWriteLen)
{	
    int nLen;//,i;
    nLen = write(COMFD,(void *)byWriteBuf, nWriteLen);	
    return nLen;
}





int main(void)
{
	int UdpSocket =0;
	int UdpReket = 0;
	struct sockaddr_in Socket_SendKey;
	int i =0;
	struct MSG_TCOCMD SendMsg;
	int ret =0;
	int SocketRecvLen;
	UdpSocket = CreateUDP();
	Socket_SendKey.sin_family = AF_INET;
	Socket_SendKey.sin_port = htons(8880);

	Socket_SendKey.sin_addr.s_addr =inet_addr("127.0.0.1");
	bzero(&(Socket_SendKey.sin_zero), 8);
	strncpy(&SendMsg,"000301UX01"TCOCMD_REMOTCOMD"0          ",strlen("000301UX01"TCOCMD_REMOTCOMD"0          "));
	while(1)
	for(i=0;i<KeyNumber;i++)
	{
		sprintf(SendMsg.Param,"%d%c",KeyValue[i],0x00);
		ret = UDP_Send(UdpSocket,&SendMsg,Socket_SendKey);		
		echoic("Send<%d> str=<%s>",ret,&SendMsg);
		usleep(1000*500);
	}


}




